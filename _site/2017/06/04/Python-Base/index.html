<!DOCTYPE html>
<html>
  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" >
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<title>Python语言笔记</title>
	<meta name="description" content="云飞的个人博客、web、后端、javascript、css、html、H5、CSS3、web工程师、gulp、jekyll、git">
	<meta name="keywords" content="web、后端、webapp、个人博客、技术博客、github博客、javascript、css、html、H5、CSS3、web工程师、gulp" />
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="msapplication-tap-highlight" content="no">
	<meta name="author" contect="maoxiaoke, maoxiaoke@outlook.com">
	<meta name="robots" content="index,follow">
	<link rel="shortcut icon" href="/styles/images/favicon.png">
	<link rel="icon" href="/styles/images/favicon.png">
	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="canonical" href="http://localhost:4000">
	<!--[if lte IE 9]>
    	<script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
  	<![endif]-->
	<!--[if lt IE 9]>
    	<script>window.location.href='/upgrade-your-browser.html';</script>
    <![endif]-->
	<script>
		var _hmt = _hmt || [];
		(function() {
  			var hm = document.createElement("script");
  			hm.src = "https://hm.baidu.com/hm.js?40ab350f7c60a488b8e8093960c0faf2";
  			var s = document.getElementsByTagName("script")[0]; 
  			s.parentNode.insertBefore(hm, s);
		})();
	</script>
</head>
  <body class="index">
    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">
        <img src="/styles/images/logo.png" alt="小可嗒嗒的个人博客">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li></li>
        <li>
          <a href="/">首页</a>
        </li>
        <li>
          <a href="/categories/">博文分类</a>
        </li>
        <li>
          <a href="/tag">标签目录</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">

        <li><a rel="nofollow" href="/about">关于我</a></li>



        <!--<li><a rel="nofollow" target="_blank" href="https://liusha529.github.io/">关于我</a></li>-->

      </ul>
    </nav>
  </div>
</header>
    <div class="docs-header pa" id="content">
    <canvas id="mycanvas">你的浏览器不支持canvas</canvas>
    <div class="container" >
  	
        <!--
		    <h1>Python语言笔记</h1>
		    <p>Post on Jun 04, 2017 by <a href="/about">LiuSha</a></p>
		-->
        <h1>我们笑着说再见，却深知再见遥遥无期。</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container lh30">
  	
    	<a href="/categories/#研究生涯-ref">研究生涯</a>	/
    	<a href="/tag/#Python-ref">Python</a>
    
      <div id="search-container" class="pull-right">
          <input type="text" id="search-input" placeholder=" 试试直接搜索吧...">
          <label class="searchIcon glyphicon glyphicon-search" for="search-input"></label>
          <ul id="results-container"></ul>
      </div>
  </div>
</div>

    
    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2018">2018</a>
          <ul class="nav">
            <li><a href="#month_2018_January">January</a></li>
      

      
        
            </ul>
          </li>
          <li><a href="#year_2017">2017</a>
            <ul class="nav">
              <li><a href="#month_2017_October">October</a></li>
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_August">August</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_July">July</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_June">June</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_May">May</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_April">April</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_March">March</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_February">February</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_January">January</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
        
            </ul>
          </li>
          <li><a href="#year_2015">2015</a>
            <ul class="nav">
              <li><a href="#month_2015_February">February</a></li>
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">Python语言笔记</h1>
              <!--
                <p class="post-meta">Jun 4, 2017</p>
              -->
              <div class="meta">Date： <span class="postdate">Jun 04, 2017</span> Author： <a target="_blank" href="http://localhost:4000">LiuSha</a></div>
              <br />
              <blockquote><p>本文章采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh"> 知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 </a>进行许可。转载请注明来自<a href="http://xiaokedada.com">小可嗒嗒的博客</a></p></blockquote>
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#内置数据类型" id="markdown-toc-内置数据类型">内置数据类型</a>    <ul>
      <li><a href="#整数类型" id="markdown-toc-整数类型">整数类型</a>        <ul>
          <li><a href="#运算" id="markdown-toc-运算">运算</a></li>
        </ul>
      </li>
      <li><a href="#浮点数" id="markdown-toc-浮点数">浮点数</a>        <ul>
          <li><a href="#运算-1" id="markdown-toc-运算-1">运算</a></li>
        </ul>
      </li>
      <li><a href="#布尔值" id="markdown-toc-布尔值">布尔值</a></li>
      <li><a href="#字符串" id="markdown-toc-字符串">字符串</a></li>
      <li><a href="#比较运算符" id="markdown-toc-比较运算符">比较运算符</a></li>
      <li><a href="#类型转换" id="markdown-toc-类型转换">类型转换</a>        <ul>
          <li><a href="#显式类型转换" id="markdown-toc-显式类型转换">显式类型转换</a></li>
          <li><a href="#隐式类型转换" id="markdown-toc-隐式类型转换">隐式类型转换</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#选择结构和循环结构" id="markdown-toc-选择结构和循环结构">选择结构和循环结构</a>    <ul>
      <li><a href="#选择结构" id="markdown-toc-选择结构">选择结构</a>        <ul>
          <li><a href="#if语句" id="markdown-toc-if语句">if语句</a></li>
          <li><a href="#else语句" id="markdown-toc-else语句">else语句</a></li>
        </ul>
      </li>
      <li><a href="#循环结构" id="markdown-toc-循环结构">循环结构</a>        <ul>
          <li><a href="#while语句" id="markdown-toc-while语句">while语句</a></li>
          <li><a href="#for语句" id="markdown-toc-for语句">for语句</a></li>
        </ul>
      </li>
      <li><a href="#循环和中断" id="markdown-toc-循环和中断">循环和中断</a>        <ul>
          <li><a href="#break语句" id="markdown-toc-break语句">break语句</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#数组" id="markdown-toc-数组">数组</a>    <ul>
      <li><a href="#一维数组" id="markdown-toc-一维数组">一维数组</a>        <ul>
          <li><a href="#创建数组" id="markdown-toc-创建数组">创建数组</a></li>
          <li><a href="#数组别名" id="markdown-toc-数组别名">数组别名</a></li>
          <li><a href="#数组复制" id="markdown-toc-数组复制">数组复制</a></li>
          <li><a href="#数组切片" id="markdown-toc-数组切片">数组切片</a></li>
          <li><a href="#创建数组与初始化" id="markdown-toc-创建数组与初始化">创建数组与初始化</a></li>
        </ul>
      </li>
      <li><a href="#二维数组" id="markdown-toc-二维数组">二维数组</a>        <ul>
          <li><a href="#创建数组-1" id="markdown-toc-创建数组-1">创建数组</a></li>
          <li><a href="#初始化" id="markdown-toc-初始化">初始化</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#函数" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#函数定义" id="markdown-toc-函数定义">函数定义</a></li>
      <li><a href="#控制流程" id="markdown-toc-控制流程">控制流程</a></li>
      <li><a href="#变量的作用范围" id="markdown-toc-变量的作用范围">变量的作用范围</a></li>
      <li><a href="#默认参数" id="markdown-toc-默认参数">默认参数</a></li>
      <li><a href="#类型检查" id="markdown-toc-类型检查">类型检查</a></li>
      <li><a href="#传递参数和返回值" id="markdown-toc-传递参数和返回值">传递参数和返回值</a>        <ul>
          <li><a href="#通过对象引用实现调用" id="markdown-toc-通过对象引用实现调用">通过对象引用实现调用</a></li>
          <li><a href="#不可变性和别名" id="markdown-toc-不可变性和别名">不可变性和别名</a></li>
          <li><a href="#数组作为参数" id="markdown-toc-数组作为参数">数组作为参数</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#模块和客户端" id="markdown-toc-模块和客户端">模块和客户端</a>    <ul>
      <li><a href="#调用其它程序中的函数的步骤" id="markdown-toc-调用其它程序中的函数的步骤">调用其它程序中的函数的步骤</a>        <ul>
          <li><a href="#在客户端导入模块" id="markdown-toc-在客户端导入模块">在客户端导入模块</a></li>
          <li><a href="#在客户端中限定函数调用的模块" id="markdown-toc-在客户端中限定函数调用的模块">在客户端中限定函数调用的模块</a></li>
          <li><a href="#在模块中编写测试客户端" id="markdown-toc-在模块中编写测试客户端">在模块中编写测试客户端</a></li>
          <li><a href="#在模块中消除全局代码" id="markdown-toc-在模块中消除全局代码">在模块中消除全局代码</a></li>
          <li><a href="#使得模块可被客户端调用" id="markdown-toc-使得模块可被客户端调用">使得模块可被客户端调用</a></li>
        </ul>
      </li>
      <li><a href="#模块化程序设计" id="markdown-toc-模块化程序设计">模块化程序设计</a>        <ul>
          <li><a href="#实现implementation" id="markdown-toc-实现implementation">实现(Implementation)</a></li>
          <li><a href="#客户端client" id="markdown-toc-客户端client">客户端(Client)</a></li>
          <li><a href="#应用程序编程接口api" id="markdown-toc-应用程序编程接口api">应用程序编程接口(API)</a></li>
          <li><a href="#私有函数private-function" id="markdown-toc-私有函数private-function">私有函数(Private function)</a></li>
          <li><a href="#库library" id="markdown-toc-库library">库(Library)</a></li>
          <li><a href="#文档documentation" id="markdown-toc-文档documentation">文档(Documentation)</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#对象" id="markdown-toc-对象">对象</a>    <ul>
      <li><a href="#对象引用" id="markdown-toc-对象引用">对象引用</a></li>
      <li><a href="#变量" id="markdown-toc-变量">变量</a></li>
    </ul>
  </li>
  <li><a href="#递归" id="markdown-toc-递归">递归</a>    <ul>
      <li><a href="#递归的含义" id="markdown-toc-递归的含义">递归的含义</a></li>
      <li><a href="#编写递归函数必须小心" id="markdown-toc-编写递归函数必须小心">编写递归函数必须小心</a>        <ul>
          <li><a href="#不能缺少基本情况" id="markdown-toc-不能缺少基本情况">不能缺少基本情况</a></li>
          <li><a href="#不能保证收敛" id="markdown-toc-不能保证收敛">不能保证收敛</a></li>
          <li><a href="#过量的内存需求" id="markdown-toc-过量的内存需求">过量的内存需求</a></li>
          <li><a href="#避免过量的重复计算" id="markdown-toc-避免过量的重复计算">避免过量的重复计算</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#面向对象的程序设计" id="markdown-toc-面向对象的程序设计">面向对象的程序设计</a>    <ul>
      <li><a href="#数据类型" id="markdown-toc-数据类型">数据类型</a>        <ul>
          <li><a href="#方法" id="markdown-toc-方法">方法</a></li>
          <li><a href="#字符串处理" id="markdown-toc-字符串处理">字符串处理</a></li>
        </ul>
      </li>
      <li><a href="#用户自定义数据类型" id="markdown-toc-用户自定义数据类型">用户自定义数据类型</a>        <ul>
          <li><a href="#api" id="markdown-toc-api">API</a></li>
          <li><a href="#文件命名规则" id="markdown-toc-文件命名规则">文件命名规则</a></li>
          <li><a href="#用户自定义数据类型和内置数据类型的不同之处" id="markdown-toc-用户自定义数据类型和内置数据类型的不同之处">用户自定义数据类型和内置数据类型的不同之处</a></li>
        </ul>
      </li>
      <li><a href="#创建数据类型" id="markdown-toc-创建数据类型">创建数据类型</a>        <ul>
          <li><a href="#设计其api至关重要" id="markdown-toc-设计其api至关重要">设计其API:至关重要</a></li>
          <li><a href="#实现一个python类以满足api规范" id="markdown-toc-实现一个python类以满足api规范">实现一个Python类以满足API规范</a></li>
        </ul>
      </li>
      <li><a href="#设计数据类型" id="markdown-toc-设计数据类型">设计数据类型</a>        <ul>
          <li><a href="#设计api" id="markdown-toc-设计api">设计API</a></li>
          <li><a href="#封装" id="markdown-toc-封装">封装</a></li>
          <li><a href="#不可变性" id="markdown-toc-不可变性">不可变性</a></li>
          <li><a href="#元组tuple" id="markdown-toc-元组tuple">元组(Tuple)</a></li>
          <li><a href="#多态性" id="markdown-toc-多态性">多态性</a></li>
          <li><a href="#运算符重载" id="markdown-toc-运算符重载">运算符重载</a></li>
          <li><a href="#函数是对象" id="markdown-toc-函数是对象">函数是对象</a></li>
          <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>将以前看的<em>Introduction to Programming in Python</em>时做的笔记，特地整理了一下放在博客上。书籍是开源的，内容可以到这个<a href="http://introcs.cs.princeton.edu/python/home/"><code class="highlighter-rouge">http://introcs.cs.princeton.edu/python/home/</code></a>网站获取。结构如下：</p>

<ul>
  <li>1.1 <a href="#内置数据类型">内置数据类型</a></li>
  <li>1.2 <a href="#选择结构和循环结构">选择结构和循环结构</a></li>
  <li>1.3 <a href="#数组">数组</a></li>
  <li>2.1 <a href="#函数">函数</a></li>
  <li>2.2 <a href="#模块和客户端">模块和客户端</a></li>
  <li>2.3 <a href="#对象">对象</a></li>
  <li>2.4 <a href="#递归">递归</a></li>
  <li>3.1 <a href="#面向对象的程序设计">面向对象的程序设计</a></li>
</ul>

<!-- more -->

<h2 id="内置数据类型">内置数据类型</h2>

<h3 id="整数类型">整数类型</h3>

<p><strong>int数据类型用于表示整数或自然数</strong>。</p>

<p>python语言中，int的取值范围可以为<strong>任意大</strong>，仅受限于计算机系统的可用内存量。</p>

<h4 id="运算">运算</h4>

<ul>
  <li>加 <code class="highlighter-rouge">+</code></li>
  <li>减 <code class="highlighter-rouge">-</code></li>
  <li>乘 <code class="highlighter-rouge">*</code></li>
  <li>整除 <code class="highlighter-rouge">//</code></li>
  <li>取余 <code class="highlighter-rouge">%</code></li>
  <li>乘幂 <code class="highlighter-rouge">**</code></li>
  <li>一元运算符 <code class="highlighter-rouge">+</code> / <code class="highlighter-rouge">-</code>。表示整型数值的正负号。</li>
</ul>

<blockquote>
  <p>注意：</p>

  <ol>
    <li>
      <p><code class="highlighter-rouge">**</code>乘幂运算符是<strong>右结合</strong>。
例如，<code class="highlighter-rouge">2**2**3</code>的结果是256。</p>
    </li>
    <li>
      <p>python3中，浮点数除法运算符<code class="highlighter-rouge">/</code>作用于两个整数时，结果为浮点数，这与浮点数除法行为一致。例如，<code class="highlighter-rouge">17/2</code>的求值结果是8.5。<strong>与python2不一致。</strong></p>
    </li>
    <li>
      <p><code class="highlighter-rouge">-47//5</code>的求值结果是<code class="highlighter-rouge">-10</code>。因为运算符<code class="highlighter-rouge">//</code>是向下取整，即向负的无穷大取整。但是，<code class="highlighter-rouge">-47%5</code>的求值结果是<code class="highlighter-rouge">3</code>，原因是对于表达式<code class="highlighter-rouge">a%b</code>，计算结果的符号与<code class="highlighter-rouge">b</code>一致。</p>
    </li>
  </ol>
</blockquote>

<h3 id="浮点数">浮点数</h3>

<p><strong>float数据类型用于表示浮点数值</strong>。</p>

<p>浮点数字字面量可使用一系列数字加小数点来指定。</p>

<h4 id="运算-1">运算</h4>
<ul>
  <li>加 <code class="highlighter-rouge">+</code></li>
  <li>减 <code class="highlighter-rouge">-</code></li>
  <li>乘 <code class="highlighter-rouge">*</code></li>
  <li>除 <code class="highlighter-rouge">/</code></li>
  <li>乘幂 <code class="highlighter-rouge">**</code></li>
</ul>

<h3 id="布尔值">布尔值</h3>

<p><strong>bool数据类型用于表示逻辑值：True / False.</strong></p>

<ul>
  <li>逻辑与： <code class="highlighter-rouge">and</code></li>
  <li>逻辑或： <code class="highlighter-rouge">or</code></li>
  <li>逻辑非： <code class="highlighter-rouge">not</code></li>
</ul>

<h3 id="字符串">字符串</h3>

<p><strong>str数据类型</strong>用于表示文本处理的字符串。</p>

<p>str字面量可使用包括在单引号之间的字符系列指定。</p>

<ul>
  <li>运算符<code class="highlighter-rouge">+</code>可以用于拼接两个字符串，然后返回一个新的str对象。</li>
  <li>内置函数<code class="highlighter-rouge">str()</code>可把数值转换为字符串。</li>
</ul>

<h3 id="比较运算符">比较运算符</h3>

<ul>
  <li>等于： <code class="highlighter-rouge">==</code></li>
  <li>不等于： <code class="highlighter-rouge">!=</code></li>
  <li>小于： <code class="highlighter-rouge">&lt;</code></li>
  <li>小于或等于： <code class="highlighter-rouge">&lt;=</code></li>
  <li>大于： <code class="highlighter-rouge">&gt;</code></li>
  <li>大于或等于： <code class="highlighter-rouge">&gt;=</code></li>
</ul>

<h3 id="类型转换">类型转换</h3>

<h4 id="显式类型转换">显式类型转换</h4>

<p>显示类型转换使用转换函数进行类型转换</p>

<ul>
  <li><code class="highlighter-rouge">str(x)</code> - 将x转换为字符串数据类型</li>
  <li><code class="highlighter-rouge">int(x)</code> - 将字符串x转换为整数数据类型，或者将浮点数x转换为整数数据类型</li>
  <li><code class="highlighter-rouge">float(x)</code> - 将字符串或整数x转换为浮点数据类型</li>
  <li><code class="highlighter-rouge">round(x)</code> - 四舍五入取整</li>
</ul>

<h4 id="隐式类型转换">隐式类型转换</h4>

<ul>
  <li>整数到浮点数：python会自动将整数转换为浮点数</li>
</ul>

<hr />

<h2 id="选择结构和循环结构">选择结构和循环结构</h2>

<h3 id="选择结构">选择结构</h3>

<h4 id="if语句">if语句</h4>

<p><strong>语法：</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if &lt;boolean expression&gt;:
    &lt;statement&gt;
    &lt;statement&gt;
    ...
</code></pre></div></div>

<blockquote>
  <p>上述<code class="highlighter-rouge">if</code>语句解释为：如果“布尔表达式”的求值结果是<code class="highlighter-rouge">True</code>，则执行<strong>缩进部分的语句块</strong>。语句块下出现第一个非缩进 的行表示语句块的结束。</p>
</blockquote>

<h4 id="else语句">else语句</h4>

<p>if语句中可以加入else语句。</p>

<p><strong>语法：</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if &lt;boolean expression&gt;:
	&lt;block of statements&gt;
else:
	&lt;block of statements&gt;
</code></pre></div></div>

<h3 id="循环结构">循环结构</h3>

<h4 id="while语句">while语句</h4>

<p><strong>语法：</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while &lt;boolean expression&gt;:
	&lt;statement&gt;
	&lt;statement&gt;
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">while</code>语句中缩进的语句块称为<em>循环体</em>，布尔表达式称为<em>循环测试条件</em>。</p>
</blockquote>

<h4 id="for语句">for语句</h4>

<p>for语句有多种语法格式。其一为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for &lt;variable&gt; in range(&lt;start&gt;,&lt;stop&gt;):
	&lt;block of statements&gt;
</code></pre></div></div>

<blockquote>
  <p>内置函数<code class="highlighter-rouge">range()</code>的参数<code class="highlighter-rouge">&lt;start&gt;</code>和<code class="highlighter-rouge">&lt;stop&gt;</code>必须是整数。第一次循环时，<code class="highlighter-rouge">&lt;variable&gt;</code>的值为<code class="highlighter-rouge">&lt;start&gt;</code>,每次循环后<code class="highlighter-rouge">&lt;variable&gt;</code>的值<code class="highlighter-rouge">+1</code>,直至最后一次循环时，<code class="highlighter-rouge">&lt;variable&gt;</code>的值为<code class="highlighter-rouge">&lt;stop&gt;-1</code>。</p>
</blockquote>

<p>对于<code class="highlighter-rouge">range()</code>只带一个参数，则该参数为<code class="highlighter-rouge">&lt;stop&gt;</code>的值，<code class="highlighter-rouge">&lt;start&gt;</code>的默认值为0。</p>

<h3 id="循环和中断">循环和中断</h3>

<h4 id="break语句">break语句</h4>

<p>可表达为：执行一系列语句，如果满足循环终止条件，则退出循环。</p>

<p><em>举例</em></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while Ture:
	statement
	statement
	if &lt;boolean expression&gt;:
		break;
</code></pre></div></div>

<hr />

<h2 id="数组">数组</h2>

<p>数组是一种数据结构。主要功能是存储和处理大量数据。</p>

<h3 id="一维数组">一维数组</h3>

<h4 id="创建数组">创建数组</h4>

<p>最简单的方法就是在方括号中放置逗号分隔的字面量。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">suits</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Clubs'</span><span class="p">,</span> <span class="s">'Diamonds'</span><span class="p">,</span> <span class="s">'Hearts'</span><span class="p">,</span> <span class="s">'Spades'</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.30</span><span class="p">,</span> <span class="mf">0.60</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">]</span>
</code></pre></div></div>

<blockquote>
  <p>引用数组元素：数组名后跟方括号，方括号中指定索引，即<code class="highlighter-rouge">x[i]</code>引用数组的第i个元素。<strong><code class="highlighter-rouge">x</code>引用整个数组。</strong></p>
</blockquote>

<ul>
  <li>从0开始的索引</li>
  <li>数组长度：使用python的内置函数<code class="highlighter-rouge">len()</code>返回数组所包含元素的个数</li>
  <li>可以使用<code class="highlighter-rouge">+=</code>扩展数组的长度。</li>
  <li>数组的元素是可以更改的。</li>
  <li>内置函数：除<code class="highlighter-rouge">len()</code>之外，还包括<code class="highlighter-rouge">sum()</code> / <code class="highlighter-rouge">max()</code> / <code class="highlighter-rouge">min()</code>等</li>
</ul>

<h4 id="数组别名">数组别名</h4>

<p>如下语句：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.30</span><span class="p">,</span> <span class="mf">0.60</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">y</code>是<code class="highlighter-rouge">x</code>的<strong>别名</strong>(类似于C中的引用)。<code class="highlighter-rouge">y[1]</code>的结果同样是<code class="highlighter-rouge">0.99</code>。</p>
</blockquote>

<h4 id="数组复制">数组复制</h4>

<p>python中复制数组的一个方法是遍历数组：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
	<span class="n">y</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">for v in x:</code>是直接遍历数组，和<code class="highlighter-rouge">for v in range(len{a}):</code>的效果是一致的。</p>
</blockquote>

<h4 id="数组切片">数组切片</h4>

<p>使用数组切片操作可以复制一个数组中任意连续系列的元素到另一个数组。</p>

<p><code class="highlighter-rouge">a[i:j]</code></p>

<p>新数组所包含的元素为：<code class="highlighter-rouge">a[i],...,a[j-1]</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y = x[:]
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">x[:]</code>中，<code class="highlighter-rouge">i</code>默认为<code class="highlighter-rouge">0</code>，<code class="highlighter-rouge">j</code>默认为<code class="highlighter-rouge">len(a)</code></p>
</blockquote>

<h4 id="创建数组与初始化">创建数组与初始化</h4>

<p>一般代码可以这样实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
	<span class="n">a</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
</code></pre></div></div>
<blockquote>
  <p>甚至可以直接使用：<code class="highlighter-rouge">a = [0.0]*n</code></p>
</blockquote>

<h3 id="二维数组">二维数组</h3>

<h4 id="创建数组-1">创建数组</h4>
<p>最简单的方法是在方括号中包括以逗号分隔的一维数组。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = [[18, 19, 20], [21, 22, 23]]
</code></pre></div></div>

<h4 id="初始化">初始化</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = []
for i in range(m):
	row = [0.0]*n
	a += [row]
</code></pre></div></div>

<blockquote>
  <p>创建了一个m*n的浮点型数组。</p>
</blockquote>

<hr />

<h2 id="函数">函数</h2>

<h3 id="函数定义">函数定义</h3>

<p><img src="http://introcs.cs.princeton.edu/python/21function/images/AnatomyMethod.png" alt="" title="Defining Functions" /></p>

<ul>
  <li>第一行为<strong>函数签名(signature)</strong>，用于指定函数名称(function name)和每个形式参数变量名称。函数签名包括<strong>关键字<code class="highlighter-rouge">def</code></strong>、<strong>函数名</strong>、<strong>一个或多个形式参数变量名</strong>、<strong>英文冒号</strong>。</li>
  <li>紧跟函数签名后的缩进代码定义<strong>函数体(function body)</strong>。</li>
  <li>函数体中<strong>还可以</strong>包含一条<strong><code class="highlighter-rouge">return</code>语句</strong>。</li>
  <li>函数体还可以定义<strong>局部变量(local variable)</strong></li>
</ul>

<h3 id="控制流程">控制流程</h3>

<p><img src="http://introcs.cs.princeton.edu/python/21function/images/FlowEZ.png" alt="" /></p>

<ol>
  <li>首先，处理<code class="highlighter-rouge">import</code>语句。</li>
  <li>然后，Python处理函数定义，但不会执行函数，仅当调用函数时Python才会执行函数。</li>
  <li>执行全局代码。</li>
</ol>

<blockquote>
  <p><strong>注意：</strong>函数定义的位置必须位于调用该函数的全局代码之前。</p>
</blockquote>

<h3 id="变量的作用范围">变量的作用范围</h3>

<ul>
  <li>函数的<strong>局部变量</strong>和<strong>形参变量</strong>的作用范围仅限于函数本身。</li>
  <li>全局代码中定义的变量(全局变量)的作用范围局限于包含该变量的整个<code class="highlighter-rouge">.py</code>文件。</li>
  <li>全局代码不能引用一个函数的局部变量或形参变量。</li>
  <li>一个函数也不能引用在另一个函数中定义的局部变量或形参变量。</li>
  <li>如果在一个函数中定义的局部变量（或形参变量）与全局变量重名，则局部变量优先。</li>
</ul>

<blockquote>
  <p>软件设计的指导原则是：定义变量的作用范围越小越好。所以，强烈建议不要在函数中引用全局变量：应该使用函数形参变量实现与其函数的通信，而函数则应该使用<code class="highlighter-rouge">return</code>语句实现与其调用者的所有通信。</p>
</blockquote>

<h3 id="默认参数">默认参数</h3>

<ul>
  <li>有些API函数如<code class="highlighter-rouge">math.log(x)</code>和<code class="highlighter-rouge">math.log(x, b)</code>，如果只传入一个函数，则<code class="highlighter-rouge">b</code>默认为自然对数<code class="highlighter-rouge">e</code>。</li>
  <li>在自定义函数中，通过在函数签名的参数变量后使用等号和默认值，指定该形式参数变量为带默认值的可选参数。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def harmonic(n, r=1)
</code></pre></div></div>

<h3 id="类型检查">类型检查</h3>

<p><strong>Python语言中，不用指定形式参数变量的类型，也不用指定返回值的类型</strong>。</p>

<p>只要Python能够完成函数中的所有运算操作，Python就会执行完函数并返回结果。</p>

<p>如果由于给定对象的类型不匹配，Python无法完成一个运算操作，Python将抛出一个运行错误并指出错误类型。</p>

<blockquote>
  <p>这称为多态性(polymorphism)</p>
</blockquote>

<h3 id="传递参数和返回值">传递参数和返回值</h3>

<h4 id="通过对象引用实现调用">通过对象引用实现调用</h4>

<p>Python使用调用传递对应的实际参数来初始化形式参数变量。我们称之为“<strong>通过对象引用实现调用(call by object reference)</strong>”。(更常见的说话是值调用)</p>

<h4 id="不可变性和别名">不可变性和别名</h4>

<p>一个数据类型是不可变的(immutable)，是指该数据类型对象的值是不可变的。</p>

<p>数据类型(int/float/str/bool)都是不可变的。对于不可变的数据类型，有些操作看上去修改了对象的值，但实际上创建了一个新的对象。</p>

<p>例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = 99
j =i
j += 1
</code></pre></div></div>

<blockquote>
  <p>首先，语句<code class="highlighter-rouge">i = 99</code>创建了一个整数对象<code class="highlighter-rouge">99</code>，并把指向该对象的引用赋值给了变量<code class="highlighter-rouge">i</code>。然后执行语句<code class="highlighter-rouge">j = i</code>，把<code class="highlighter-rouge">i</code>(赋值引用)赋值给<code class="highlighter-rouge">j</code>，所以变量<code class="highlighter-rouge">i</code>和<code class="highlighter-rouge">j</code>都引用同一个对象。如果两个变量指向同一个对象，则互称别名。最后，执行<code class="highlighter-rouge">j += 1</code>，其结果是<code class="highlighter-rouge">j</code>引用一个值为<code class="highlighter-rouge">100</code>的对象，但语句并没有将已存在的值为<code class="highlighter-rouge">99</code>的整型对象的值改变为<code class="highlighter-rouge">100</code>。实际上，因为<code class="highlighter-rouge">int</code>对象为不可变对象，所以没有语句可以改变一个既存整型对象的值。事实上，该语句创建了一个新的整型对象<code class="highlighter-rouge">1</code>,加上整数<code class="highlighter-rouge">99</code>并创建另一个新的整型对象<code class="highlighter-rouge">100</code>，并把指向该整数的对象引用赋值给变量<code class="highlighter-rouge">j</code>。但是，<code class="highlighter-rouge">i</code>依旧指向原来的<code class="highlighter-rouge">99</code>。</p>
</blockquote>

<p><strong>所以传递实际参数给一个函数，实参和形参是互为别名。</strong></p>

<p>举例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def inc(j)
	j += 1
i = 99
inc(i)
</code></pre></div></div>

<blockquote>
  <p>此时，<code class="highlighter-rouge">i</code>和<code class="highlighter-rouge">j</code>互为别名。函数<code class="highlighter-rouge">inc()</code>的语句<code class="highlighter-rouge">j += 1</code>不会改变整数99，而是创建一个新的整数100，并把其对象引用赋值给变量<code class="highlighter-rouge">j</code>。但是，当函数<code class="highlighter-rouge">inc()</code>调用结束返回到调用者后，其形式参数变量<code class="highlighter-rouge">j</code>超出了作用范围，而变量<code class="highlighter-rouge">i</code>依旧指向整数99。</p>
</blockquote>

<h4 id="数组作为参数">数组作为参数</h4>

<p><strong>数组是可变(mutable)的数据类型</strong>，我们可以改变数组元素的值。</p>

<p><strong>所以，当传递一个数组作为函数的实际参数时，可以直接操作该数组(而不是该数组的副本)</strong></p>

<p>举例</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def exchange(a, i, j)
	temp = a[i]
	a[i] = a[j]
	a[j] = temp
x = [.30, .60, .10]
exchange(x, 0, 2) &gt;运算过后，`x = [0.10, 0.60, 0.30]`
</code></pre></div></div>

<hr />

<h2 id="模块和客户端">模块和客户端</h2>

<h3 id="调用其它程序中的函数的步骤">调用其它程序中的函数的步骤</h3>

<ul>
  <li>模块(module):包含可被其他程序调用的函数</li>
  <li>客户端(client):是调用其它模块中的函数的程序</li>
</ul>

<h4 id="在客户端导入模块">在客户端导入模块</h4>

<p>在客户端中，编写函数：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import module
</code></pre></div></div>

<p>目的是通知Python，客户端代码可能会调用定义在module.py中的一个或多个函数。</p>

<blockquote>
  <p>在大多数Python代码中，<code class="highlighter-rouge">import</code>语句位于程序的最开始的位置，导入标准模块的所有<code class="highlighter-rouge">import</code>语句则位于用户自定义模块的前面。</p>
</blockquote>

<h4 id="在客户端中限定函数调用的模块">在客户端中限定函数调用的模块</h4>

<p>要调用<code class="highlighter-rouge">module.py</code>中的函数，可以使用如下方式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.函数名
</code></pre></div></div>

<h4 id="在模块中编写测试客户端">在模块中编写测试客户端</h4>

<p>程序员坚持多年的最佳编程实践，就是<strong>编写代码以测试模块中各函数的功能并且将测试代码包括在模块中</strong>。</p>

<blockquote>
  <p>Python语言长久以来的传统是吧测试代码放置在名为main()的函数中。</p>
</blockquote>

<p>如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def main():
测试代码
if __name__ == '__main__':main()
</code></pre></div></div>

<h4 id="在模块中消除全局代码">在模块中消除全局代码</h4>

<p><code class="highlighter-rouge">import</code>语句会执行导入模块中的所有全局代码，所以在模块中不能遗留全局代码(这些测试代码常常向标准输出写入内容)。</p>

<p>替代方法是，将测试代码放置在<code class="highlighter-rouge">main()</code>函数中，并制定当且仅从命令行执行程序时Python才会调用测试函数<code class="highlighter-rouge">main()</code>，使用如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if __name__ == '__main__':main()
</code></pre></div></div>

<blockquote>
  <p>上述代码只是Python当<code class="highlighter-rouge">.py</code>文件从命令行直接执行时(而不是通过<code class="highlighter-rouge">import</code>语句)调用<code class="highlighter-rouge">main()</code>。</p>
</blockquote>

<h4 id="使得模块可被客户端调用">使得模块可被客户端调用</h4>

<p>当模块不是Python内置或标准模块时，Python首先在于程序<code class="highlighter-rouge">client.py</code>相同的目录中查找模块文件。所以，最简单的方法是把客户端程序文件和模块文件放在相同目录下。</p>

<h3 id="模块化程序设计">模块化程序设计</h3>

<h4 id="实现implementation">实现(Implementation)</h4>

<p>通常使用术语’Implementation’来描述实现重用的若干函数的代码。一个Python模块就是一个实现。</p>

<p>模块设计的指导性原则是：<strong>为客户端提供需要的函数，不要包含其他多余的内容</strong></p>

<h4 id="客户端client">客户端(Client)</h4>

<p>通常使用通用术语’Client’表示使用一个实现的程序。</p>

<h4 id="应用程序编程接口api">应用程序编程接口(API)</h4>

<p>API允许任何客户端直接使用模块，而无须检测模块中定义的代码。</p>

<h4 id="私有函数private-function">私有函数(Private function)</h4>

<p>有时候需要在模块中定义辅助函数，辅助函数不能被客户端直接调用，称为私有函数。</p>

<p>根据惯例，<strong>Python程序员使用下划线开始的函数名作为私有函数</strong>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def _functionname(x):
</code></pre></div></div>

<p>API一般不包括私有函数。</p>

<blockquote>
  <p>以下划线开始的函数名指示客户端不要直接调用这些函数，但Python并没有强制不允许调用私有函数的机制。</p>
</blockquote>

<h4 id="库library">库(Library)</h4>

<p>库是若干相关模块的集合</p>

<h4 id="文档documentation">文档(Documentation)</h4>

<p>通过Python<em>交互式</em>的内置函数<code class="highlighter-rouge">help()</code>,可查看标准库、扩展库模块的API。具体实施如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; import modulename
&gt;&gt;&gt; help(modulename)
</code></pre></div></div>

<hr />

<h2 id="对象">对象</h2>

<p>在Python中，所有的数据都表示为对象及对象之间的关系。Python对象是特定数据类型的值在内存中的表现方式。每个对象由其<strong>标志(identity)</strong>、<strong>类型(type)</strong>和<strong>值(value)</strong>三者标识。</p>

<ul>
  <li>标志用于唯一标识一个对象，你可将标志看作对象在计算机内存(或内存地址)中的位置。</li>
  <li>类型用于限定对象的行为–对象所表示的取值范围以及允许执行的操作集合</li>
  <li>值用于表示对象数据类型的值</li>
</ul>

<h3 id="对象引用">对象引用</h3>
<p><strong>对象引用是指对象标志的具体表示，即存储对象的内存地址</strong></p>

<h3 id="变量">变量</h3>
<p><strong>对象引用的名称</strong></p>

<hr />

<h2 id="递归">递归</h2>

<h3 id="递归的含义">递归的含义</h3>

<p><strong>函数调用自身</strong></p>

<h3 id="编写递归函数必须小心">编写递归函数必须小心</h3>

<h4 id="不能缺少基本情况">不能缺少基本情况</h4>

<p>否则，递归函数将重复调用自身，永远不会终止。</p>

<p>最终，Python会抛出RuntimeError，并报告错误信息<code class="highlighter-rouge">maximum recursion depth exceeded</code>。</p>

<h4 id="不能保证收敛">不能保证收敛</h4>

<h4 id="过量的内存需求">过量的内存需求</h4>

<p>调用自己的次数太多，Python无法保证保存递推调用所需的内存足够，从而导致<code class="highlighter-rouge">maximum depth exceeded</code>错误。</p>

<h4 id="避免过量的重复计算">避免过量的重复计算</h4>

<hr />

<h2 id="面向对象的程序设计">面向对象的程序设计</h2>

<h3 id="数据类型">数据类型</h3>

<p>Python语言中的数据类型包括两类：</p>

<ul>
  <li>内置数据类型(int / bool / float /str)</li>
  <li>用户自定义数据类型</li>
</ul>

<p><strong>一个数据类型是一系列值的集合以及定义在这些值上的一系列操作的集合</strong></p>

<h4 id="方法">方法</h4>

<p><em>调用</em>方法的语法是：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>变量名.方法名
</code></pre></div></div>

<blockquote>
  <p>方法是特定对象(即与对象的数据类型)相关联的函数。必须显式地关联一个指定的对象。</p>
</blockquote>

<p>举例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = 3 ** 100
bits = x.bit_length()
stdio.writeln(bits)
</code></pre></div></div>

<p><img src="http://introcs.cs.princeton.edu/python/31datatype/images/AnatomyMethodUse.png" alt="内置函数与方法" /></p>
<blockquote>
  <p>上述代码中，<code class="highlighter-rouge">x.bit_length()</code>就是<em>方法</em>调用，<code class="highlighter-rouge">stdio.writeln(bits)</code>就是<em>函数</em>调用。</p>
</blockquote>

<h4 id="字符串处理">字符串处理</h4>

<p><code class="highlighter-rouge">str</code>的API运算操作可分为三个类别：</p>

<ul>
  <li>内置运算符：
    <blockquote>
      <ul>
        <li><code class="highlighter-rouge">s + t</code></li>
        <li><code class="highlighter-rouge">s +=t</code></li>
        <li><code class="highlighter-rouge">s[i]</code></li>
        <li><code class="highlighter-rouge">s[i:j]</code></li>
        <li><code class="highlighter-rouge">s[i:j:k]</code></li>
        <li><code class="highlighter-rouge">s &lt; t</code></li>
        <li><code class="highlighter-rouge">s != t</code></li>
        <li><code class="highlighter-rouge">s &gt; t</code></li>
        <li>and so on</li>
      </ul>
    </blockquote>
  </li>
  <li>内置函数：
    <blockquote>
      <ul>
        <li><code class="highlighter-rouge">len()</code></li>
        <li>and so on</li>
      </ul>
    </blockquote>
  </li>
  <li>方法：
    <blockquote>
      <ul>
        <li><code class="highlighter-rouge">s.count()</code></li>
        <li><code class="highlighter-rouge">s.find()</code></li>
        <li><code class="highlighter-rouge">s.upper()</code></li>
        <li><code class="highlighter-rouge">s.lower()</code></li>
        <li><code class="highlighter-rouge">s.strip</code></li>
        <li>an so on</li>
      </ul>
    </blockquote>
  </li>
</ul>

<p><strong>实际上，上述三种运算操作的实现方法是一致的</strong>。Python自动将内置运算符和内置函数映射到特殊方法，特殊方法约定使用<strong>名称前后带双下划线</strong>的命名规则。</p>

<blockquote>
  <p>比如：<code class="highlighter-rouge">s + t</code>等价于方法调用<code class="highlighter-rouge">s.__add__(t)</code>；<code class="highlighter-rouge">len(s)</code>等价于函数调用<code class="highlighter-rouge">s.__len__()</code>。</p>
</blockquote>

<h3 id="用户自定义数据类型">用户自定义数据类型</h3>

<h4 id="api">API</h4>
<p>主要是指定构造函数，方法和内置函数。</p>

<h4 id="文件命名规则">文件命名规则</h4>

<p>一般将用户自定义数据类型的代码保存在一个独立的<code class="highlighter-rouge">.py</code>文件中，<strong>文件名与数据类型相同但不大写</strong>。在客户端我们需要通过以下的语句引入自定义的数据结构：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from charge import Charge
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">charge</code>是文件名<code class="highlighter-rouge">charge.py</code>除去后缀的部分，<code class="highlighter-rouge">Charge</code>是自定义数据类型名。</p>
</blockquote>

<h4 id="用户自定义数据类型和内置数据类型的不同之处">用户自定义数据类型和内置数据类型的不同之处</h4>

<p>内置数据类型在Python中拥有特殊地位：</p>

<ul>
  <li>可直接使用内置数据类型而无须通过<code class="highlighter-rouge">import</code>引入</li>
  <li>Python为创建内置数据类型的对象提供了特殊的语法</li>
  <li>按惯例，内置数据类型以小写字母开始，用户自定义数据类型则以大写字母开始</li>
  <li>Python为内置的算术数据类型提供自动类型转换</li>
  <li>Python为内置数据类型的转换提供了内置函数</li>
</ul>

<h3 id="创建数据类型">创建数据类型</h3>

<p>3个基本步骤：</p>

<h4 id="设计其api至关重要">设计其API:至关重要</h4>

<p>这是我们构建一个新的数据类型的蓝图</p>

<h4 id="实现一个python类以满足api规范">实现一个Python类以满足API规范</h4>

<ol>
  <li>编写构造函数
<strong>实现一个特殊方法：<code class="highlighter-rouge">__init__()</code></strong></li>
</ol>

<p><img src="http://introcs.cs.princeton.edu/python/32class/images/AnatomyConstructor.png" alt="构造函数剖析" /></p>

<blockquote>
  <p>按惯例，第一个参数变量的名称是<code class="highlighter-rouge">self</code>，作为Python默认对象创建过程，当<code class="highlighter-rouge">__init__()</code>被调用时，<code class="highlighter-rouge">self</code>参数变量的值指向新建对象。</p>
</blockquote>

<p><strong>实例变量(Instance variable)</strong>属于类的特定实例，即一个特定对象。</p>

<p>遵循规范，<strong>只能在构造函数</strong>中定义和初始化一个新建对象的实例变量，实例变量名以<strong>下划线开始</strong>。</p>

<p><strong>对象创建的详细过程</strong></p>

<ul>
  <li>Python创建对象，并调用<code class="highlighter-rouge">__init__()</code>构造函数，初始化构造函数的<code class="highlighter-rouge">self</code>参数变量为新建对象的引用。</li>
  <li>构造函数定义和初始化<code class="highlighter-rouge">self</code>引用的新建对象的实例变量</li>
  <li>当构造函数执行完毕，Python自动把执行新建对象的<code class="highlighter-rouge">self</code>引用返回给客户端</li>
  <li>客户端把引用赋值给变量</li>
</ul>

<ol>
  <li>编写方法处理实例变量以实现功能</li>
</ol>

<p><strong>实现一个方法</strong></p>

<p><img src="http://introcs.cs.princeton.edu/python/32class/images/AnatomyMethod.png" alt="一个方法剖析" /></p>

<p>方法可以访问实例变量。</p>

<p>方法的第一个参数变量名是<code class="highlighter-rouge">self</code>，当客户端调用一个方法时，Python自动设置<code class="highlighter-rouge">self</code>参数变量为指向当前操作的对象的引用，即调用方法的对象。</p>

<p><strong>方法中的变量</strong></p>

<ul>
  <li><code class="highlighter-rouge">self</code>对象的实例变量</li>
  <li>方法的参数变量</li>
  <li>局部变量</li>
</ul>

<blockquote>
  <p>每个局部变量或参数变量对应一个唯一的值，但每个实例变量则可能对应多个值(数据类型的每个对象、实例对应一个值)。</p>

  <p>另外，参数变量和局部变量的作用域是<strong>方法中</strong>，实例变量是<strong>类中</strong>。</p>
</blockquote>

<p><strong>实现一个内置函数</strong>
我们实现一个函数名的前后均带双下划线的特殊方法，其第一个参数变量为<code class="highlighter-rouge">self</code>。</p>

<p>比如：内置函数<code class="highlighter-rouge">str(c)</code>,按照Python规范，<code class="highlighter-rouge">str(c)</code>函数调用会自动转换为一个<strong>标准方法调用</strong><code class="highlighter-rouge">c.__str__()</code></p>

<p>这是一种<strong>多态性</strong>。也具有私有性。</p>

<p><img src="http://introcs.cs.princeton.edu/python/32class/images/AnatomyClass.png" alt="类定义的剖析" /></p>

<h3 id="设计数据类型">设计数据类型</h3>

<h4 id="设计api">设计API</h4>

<p>通常，构建软件最重要的和最具挑战性的步骤就是设计API。</p>

<ul>
  <li>符合API标准，通过API把客户端和实现分隔开来</li>
  <li>数据类型API包含若干方法和这些方法所提供功能的简洁描述，准确描述所有可能参数行为，包括副作用，然后编写软件检查其实现是否满足规范要求</li>
  <li>避免宽接口(Wide interface)，不要有数量众多的方法接口。很容易在一个既存的API中增加方法，然而移除方法但又要保证不破坏既存客户端则十分困难。</li>
  <li>从客户端代码开始</li>
  <li>避免对表示方式的依赖</li>
  <li>为客户端仅提供所需的方法，仅此而已</li>
</ul>

<h4 id="封装">封装</h4>

<p>将客户端和实现分离从而隐藏信息的过程称为<em>封装</em>。其主要目的是：</p>

<ul>
  <li>实现模块化设计</li>
  <li>提高调试效率</li>
  <li>是代码更加简洁</li>
</ul>

<ol>
  <li>修改API</li>
</ol>

<p><strong>一旦众多数量的客户端在使用一个模块，请千万不要随意改变其API</strong></p>

<ol>
  <li>改变实现</li>
</ol>

<p>封装的设计理念在于：我们可以使用一个程序代替另一个程序，而无须修改客户端代码</p>

<ol>
  <li>私有性</li>
</ol>

<p>Python编程社区提出一个规范：如果一个实例变量、方法或函数的名称以下划线开始，那么客户端应该把该实例变量、方法和函数作为私有变量。</p>

<p>通过这种命名规范，客户端被告知不应该直接访问名称以下划线开始的实例变量、方法和函数。</p>

<h4 id="不可变性">不可变性</h4>

<p>如果对象的数据类型值一旦创建就不可更改，则称对象为不可变对象。</p>

<h4 id="元组tuple">元组(Tuple)</h4>

<p>Python内置数据类型tuple表示一个不可变的对象序列。元组类似于内置数据类型list(也称作数组)，不同之处在于一旦创建了一个元组，就不能修改其元素。</p>

<p>在需要修改序列元素的情况下，则必须使用数组。</p>

<p>Python还支持一种强大的元组赋值功能，称为<em>元组组包</em>(tuple packing)和<em>元组解包</em>(tuple unpacking)，允许用户把右侧的一个表达式元组赋值给左侧的变量元组。</p>

<blockquote>
  <p>注意：必须保证左侧的变量个数和右侧的表达式个数一致。</p>
</blockquote>

<h4 id="多态性">多态性</h4>

<p>可带不同类型参数的方法或函数称为多态性。</p>

<h4 id="运算符重载">运算符重载</h4>

<p>在数据类型中提供运算符的自定义能力是一种多态性，称为运算符重载。</p>

<p>Python用于支持重载的机制是将每个运算符和内置函数与一个特殊方法关联起来。</p>

<blockquote>
  <p>例如：每当Python发现Python发现客户端代码中的<code class="highlighter-rouge">x + y</code>，则将该表达式转换为特殊方法调用<code class="highlighter-rouge">x.__add__(y)</code>。因而，要在自定义数据类型中重载<code class="highlighter-rouge">+</code>运算符，则只需包含特殊方法<code class="highlighter-rouge">__add__()</code>的一种实现即可。</p>
</blockquote>

<p><strong>算术运算符</strong></p>

<ul>
  <li><code class="highlighter-rouge">x + y</code> : ` <strong>add</strong>(self, other)`</li>
  <li><code class="highlighter-rouge">x - y</code> : <code class="highlighter-rouge">__sub__(self, other)</code></li>
  <li><code class="highlighter-rouge">x * y</code> : <code class="highlighter-rouge">__mul__(self, other)</code></li>
  <li><code class="highlighter-rouge">x ** y</code> : <code class="highlighter-rouge">__pow__(self, other)</code></li>
  <li><code class="highlighter-rouge">x / y</code> : <code class="highlighter-rouge">__truediv__(self, other)</code></li>
  <li><code class="highlighter-rouge">x // y</code> : <code class="highlighter-rouge">__floordiv__(self, other)</code></li>
  <li><code class="highlighter-rouge">x % y</code> : <code class="highlighter-rouge">__mod__(self, other)</code></li>
  <li><code class="highlighter-rouge">+x</code> : <code class="highlighter-rouge">__pos__(self, other)</code></li>
  <li><code class="highlighter-rouge">-x</code> : <code class="highlighter-rouge">__neg__(self, other)</code></li>
</ul>

<p><strong>等性运算符</strong></p>

<p>用于测试相等与否的运算符<code class="highlighter-rouge">==</code>和<code class="highlighter-rouge">!=</code>值得特别注意。因为Python中有两种相等的方式：</p>

<ul>
  <li>引用相等(标识相等): 当两个引用相等(即引用同一个对象)时，引用相等成立。内置函数<code class="highlighter-rouge">id()</code>返回对象的内存地址。<code class="highlighter-rouge">is</code>和<code class="highlighter-rouge">is not</code>运算符测试两个变量是否引用同一对象。</li>
  <li>对象相等(值相等)：当两个对象相等(即包含相同数据类型值)时，对象相等成立。我们应该使用运算符<code class="highlighter-rouge">==</code>和<code class="highlighter-rouge">!=</code>(定义为特殊方法：<code class="highlighter-rouge">__eq__()</code>和<code class="highlighter-rouge">__ne__()</code>)测试对象的相等性。</li>
</ul>

<blockquote>
  <p>如果没有定义<code class="highlighter-rouge">__eq__()</code>方法，则Python使用<code class="highlighter-rouge">is</code>运算符代替，即默认<code class="highlighter-rouge">==</code>实现为引用相等性。</p>
</blockquote>

<p><strong>哈希法</strong></p>

<p>略。</p>

<p><strong>比较运算符</strong></p>

<ul>
  <li><code class="highlighter-rouge">x &lt; y</code> : <code class="highlighter-rouge">__lt__(self,other)</code></li>
  <li><code class="highlighter-rouge">x &lt;= y</code> : <code class="highlighter-rouge">__le__(self,other)</code></li>
  <li><code class="highlighter-rouge">x &gt;= y</code> : <code class="highlighter-rouge">__ge__(self,other)</code></li>
  <li><code class="highlighter-rouge">x &gt; y</code> : <code class="highlighter-rouge">__gt__(self,other)</code></li>
</ul>

<p><strong>其他运算符</strong></p>

<p>在Python语言中，几乎所有的运算符都可以被重载。</p>

<p><strong>内置函数</strong></p>

<p>可以重载内置函数。</p>

<ul>
  <li><code class="highlighter-rouge">len(x)</code> : <code class="highlighter-rouge">__len__(self)</code></li>
  <li><code class="highlighter-rouge">float(x)</code> : <code class="highlighter-rouge">__float__(self)</code></li>
  <li><code class="highlighter-rouge">int(x)</code> : <code class="highlighter-rouge">__int__(self)</code></li>
  <li><code class="highlighter-rouge">str(x)</code> : <code class="highlighter-rouge">__str__(self)</code></li>
  <li><code class="highlighter-rouge">abs(x)</code> : <code class="highlighter-rouge">__abs__(self)</code></li>
  <li><code class="highlighter-rouge">hash(x)</code> : <code class="highlighter-rouge">__hash__(self)</code></li>
  <li><code class="highlighter-rouge">iter(x)</code> : <code class="highlighter-rouge">__iter__(self)</code></li>
</ul>

<h4 id="函数是对象">函数是对象</h4>

<p>在Python语言中，一切(包括函数)皆是对象。</p>

<p>这意味着函数可以作为另一个函数的参数和返回值，这种做法叫做<strong>高阶函数</strong>。</p>

<h4 id="继承">继承</h4>

<p>继承的使用存在争议，因为继承一般会与封装违背。所以，略。</p>


            </article>
          <hr>
          <blockquote><p>对于本文内容有问题或建议的小伙伴，欢迎在文章底部留言交流讨论。</p></blockquote>
        </div>
      </div>
      <!--comment-->
      <!--code for 网易云跟帖
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
            <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
            <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
            <script>
            var cloudTieConfig = {
            url: document.location.href, 
            sourceId: "",
            productKey: "b6d55f09637f497389b80bafc11aada1",
            target: "cloud-tie-wrapper"
            };
            var yunManualLoad = true;
            Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
            </script>
          </div>
        </article>
      </div> -->
      <!--Gitment-->
      <div id="container"></div>
      <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
      <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
      <script>
        var gitment = new Gitment({
          id: window.location.pathname, 
          owner: 'liusha529',
          repo: 'liusha529.github.io',
          oauth: {
          client_id: 'b389957bf0758092f3eb',
          client_secret: 'b84e22f17551d822d114d1d1d06244bc8d5fc987',
          },
        })
        gitment.render('container')
      </script>
      
    </div>
  </div>
</div>


    <footer class="footer" role="contentinfo">
	<!--不蒜子pv/uv统计-->
	<div class="post-meta">
            <p>Total <span id="busuanzi_value_site_pv"></span> views，您是本站的第<span id="busuanzi_value_site_uv"></span>个小伙伴，<span id="busuanzi_value_page_pv"></span> Hits</p><br/>
    </div>
	<div class="container">
		<p class="copyright">Copyright © 2017   <a href="https://github.com/maoxiaoke/maoxiaoke.github.io" target="_blank"><code>M/J.</code></a> All rights reserved. </p>
		<p>Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>， Data by <a href="https://tongji.baidu.com/web/23811489/overview/index" target="_blank">Bai Du</a>.</p>
	</div>
	<ul id="gotop"><li><span>TOP</span></li></ul>
</footer>
<script src="http://apps.bdimg.com/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="http://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="/styles/js/function.min.js"></script>
<script src="/styles/js/lessismore.js"></script>
<script src="/styles/js/application.min.js"></script>
  </body>
</html>
