<!DOCTYPE html>
<html>
  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" >
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<title>让人头疼的函数内this的指向</title>
	<meta name="description" content="云飞的个人博客、web、后端、javascript、css、html、H5、CSS3、web工程师、gulp、jekyll、git">
	<meta name="keywords" content="web、后端、webapp、个人博客、技术博客、github博客、javascript、css、html、H5、CSS3、web工程师、gulp" />
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="msapplication-tap-highlight" content="no">
	<meta name="author" contect="maoxiaoke, maoxiaoke@outlook.com">
	<meta name="robots" content="index,follow">
	<link rel="shortcut icon" href="/styles/images/favicon.png">
	<link rel="icon" href="/styles/images/favicon.png">
	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="canonical" href="http://localhost:4000">
	<!--[if lte IE 9]>
    	<script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
  	<![endif]-->
	<!--[if lt IE 9]>
    	<script>window.location.href='/upgrade-your-browser.html';</script>
    <![endif]-->
	<script>
		var _hmt = _hmt || [];
		(function() {
  			var hm = document.createElement("script");
  			hm.src = "https://hm.baidu.com/hm.js?40ab350f7c60a488b8e8093960c0faf2";
  			var s = document.getElementsByTagName("script")[0]; 
  			s.parentNode.insertBefore(hm, s);
		})();
	</script>
</head>
  <body class="index">
    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">
        <img src="/styles/images/logo.png" alt="小可嗒嗒的个人博客">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li></li>
        <li>
          <a href="/">首页</a>
        </li>
        <li>
          <a href="/categories/">博文分类</a>
        </li>
        <li>
          <a href="/tag">标签目录</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">

        <li><a rel="nofollow" href="/about">关于我</a></li>



        <!--<li><a rel="nofollow" target="_blank" href="https://liusha529.github.io/">关于我</a></li>-->

      </ul>
    </nav>
  </div>
</header>
    <div class="docs-header pa" id="content">
    <canvas id="mycanvas">你的浏览器不支持canvas</canvas>
    <div class="container" >
  	
        <!--
		    <h1>让人头疼的函数内this的指向</h1>
		    <p>Post on Aug 16, 2017 by <a href="/about">LiuSha</a></p>
		-->
        <h1>我们笑着说再见，却深知再见遥遥无期。</h1>
    
  </div>
</div>
    
      
<div class="banner">
  <div class="container lh30">
  	
    	<a href="/categories/#研究生涯-ref">研究生涯</a>	/
    	<a href="/tag/#JavaScript-ref">JavaScript</a>
    
      <div id="search-container" class="pull-right">
          <input type="text" id="search-input" placeholder=" 试试直接搜索吧...">
          <label class="searchIcon glyphicon glyphicon-search" for="search-input"></label>
          <ul id="results-container"></ul>
      </div>
  </div>
</div>

    
    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2018">2018</a>
          <ul class="nav">
            <li><a href="#month_2018_January">January</a></li>
      

      
        
            </ul>
          </li>
          <li><a href="#year_2017">2017</a>
            <ul class="nav">
              <li><a href="#month_2017_October">October</a></li>
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_August">August</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_July">July</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_June">June</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_May">May</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_April">April</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_March">March</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_February">February</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2017_January">January</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
        
            </ul>
          </li>
          <li><a href="#year_2015">2015</a>
            <ul class="nav">
              <li><a href="#month_2015_February">February</a></li>
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">让人头疼的函数内this的指向</h1>
              <!--
                <p class="post-meta">Aug 16, 2017</p>
              -->
              <div class="meta">Date： <span class="postdate">Aug 16, 2017</span> Author： <a target="_blank" href="http://localhost:4000">LiuSha</a></div>
              <br />
              <blockquote><p>本文章采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh"> 知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 </a>进行许可。转载请注明来自<a href="http://xiaokedada.com">小可嗒嗒的博客</a></p></blockquote>
            </header>
            <article class="post-content">
              <ul id="markdown-toc">
  <li><a href="#默认绑定--default-binding" id="markdown-toc-默认绑定--default-binding">默认绑定 – Default binding</a></li>
  <li><a href="#隐式绑定--implicit-binding" id="markdown-toc-隐式绑定--implicit-binding">隐式绑定 – Implicit Binding</a>    <ul>
      <li><a href="#隐式丢失--implicitly-lost" id="markdown-toc-隐式丢失--implicitly-lost">隐式丢失 – Implicitly Lost</a></li>
    </ul>
  </li>
  <li><a href="#显式绑定--explicit-binding" id="markdown-toc-显式绑定--explicit-binding">显式绑定 – Explicit Binding</a>    <ul>
      <li><a href="#硬绑定--hard-binding" id="markdown-toc-硬绑定--hard-binding">硬绑定 – Hard Binding</a></li>
    </ul>
  </li>
  <li><a href="#new-绑定--new-binding" id="markdown-toc-new-绑定--new-binding">new 绑定 – new Binding</a></li>
  <li><a href="#四种规则的顺序" id="markdown-toc-四种规则的顺序">四种规则的顺序</a></li>
  <li><a href="#特殊的-this" id="markdown-toc-特殊的-this">特殊的 this</a>    <ul>
      <li><a href="#在闭包中使用-this" id="markdown-toc-在闭包中使用-this">在闭包中使用 this</a></li>
      <li><a href="#iife-中使用-this" id="markdown-toc-iife-中使用-this">IIFE 中使用 this</a></li>
      <li><a href="#传递-null-或-undefined" id="markdown-toc-传递-null-或-undefined">传递 null 或 undefined</a></li>
      <li><a href="#箭头函数" id="markdown-toc-箭头函数">箭头函数</a></li>
    </ul>
  </li>
  <li><a href="#callapply-和-bind" id="markdown-toc-callapply-和-bind">call、apply 和 bind</a></li>
  <li><a href="#new-的四个步骤" id="markdown-toc-new-的四个步骤">new 的四个步骤</a></li>
</ul>

<p>JavaScript 颇让费解的东西 this 为何出现呢，机制是<strong>提供更优雅的方式来隐式地“传递”一个对象引用</strong>。对于 this 的很多误解和使用，建议收看 <a href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a>。本文主要是在它的基础上整合的内容。</p>

<p>每个函数在被调用时都会自动取得两个特殊的变量: this 和 arguments。需要说明的是，this 不是编写时绑定，而是<strong>运行时</strong>绑定。它依赖于函数调用的上下文条件。this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</p>

<!-- more -->

<p>首先，提到台面上来。<strong>this 是一个完全根据调用点(call-site)来为函数调用建立绑定。</strong></p>

<blockquote>
  <p>这句话不太好理解</p>
</blockquote>

<p>决定 this 的指向有四种规则。</p>

<h2 id="默认绑定--default-binding">默认绑定 – Default binding</h2>

<p>这种 this 规则是在没有其他规则适用情况下的默认规则。</p>

<p>最常见的情况就是： 独立函数调用。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">//函数的调用点</span>
</code></pre></div></div>

<p>foo() 被一个直白的，毫无修饰的函数引用(即 foo，对于命名函数来讲，它就是一个引用)调用的，所以 this 指向全局对象(Global)。</p>

<blockquote>
  <p>如果 strict mode 在这里生效，那么对于<em>默认绑定</em>来说全局对象是不合法的，所以 this 将被设置为 undefined。</p>
</blockquote>

<hr />

<h2 id="隐式绑定--implicit-binding">隐式绑定 – Implicit Binding</h2>

<p>第二种规则是考虑<strong>调用点是否有一个上下文对象(context object)</strong>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// 调用点</span>
</code></pre></div></div>

<p>foo() 被声明然后作为引用属性添加到 obj。调用点使用 obj 这个上下文(环境) 来调用 foo() 函数，可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个函数引用。所以，obj 就是 foo() 调用的 this。</p>

<p><strong>敲黑板，划重点了</strong></p>

<h3 id="隐式丢失--implicitly-lost">隐式丢失 – Implicitly Lost</h3>

<p>当一个 隐式绑定丢失了它的绑定，这通常意味着它会退回到 默认绑定。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span> <span class="c1">// 函数引用！</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">"oops, global"</span><span class="p">;</span> <span class="c1">// `a` 也是一个全局对象的属性</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">// "oops, global"</span>
</code></pre></div></div>

<p>尽管 bar 似乎是 obj.foo 的引用，但实际上它只是另一个 foo 本身的引用而已。<strong>起作用的调用点是 bar()</strong>，一个直白，毫无修饰的调用。所以，默认绑定适用在这里。</p>

<p>更意外的一种方式是当我们考虑<strong>传递一个回调函数</strong>时:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">doFoo</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `fn` 只不过 `foo` 的另一个引用</span>
    <span class="nx">fn</span><span class="p">();</span> <span class="c1">// &lt;-- 调用点!</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">"oops, global"</span><span class="p">;</span> <span class="c1">// `a` 也是一个全局对象的属性</span>
<span class="nx">doFoo</span><span class="p">(</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="p">);</span> <span class="c1">// "oops, global"</span>
</code></pre></div></div>

<p>和上面的例子一致，fn 不过是 foo 的另一个引用，所以结果和上面的例子一样。</p>

<hr />

<h2 id="显式绑定--explicit-binding">显式绑定 – Explicit Binding</h2>

<p>如果你想强制一个函数调用使用某个特定对象作为 this 绑定，具体地说，函数拥有 <code class="highlighter-rouge">call()</code> 和 <code class="highlighter-rouge">apply()</code> 方法，它们提供一些特殊的功能。你创建的所有函数，都可以访问 call() 和 apply()。</p>

<p>这些工具接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="nx">obj</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>但是，单独依靠 显式绑定 并不能解决函数“丢失”自己原本的 this 绑定的这个问题。</p>

<blockquote>
  <p>??? why??</p>
</blockquote>

<p>我们还是用一个回调函数来讨论一下:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">"oops, global"</span><span class="p">;</span> <span class="c1">// `a` 也是一个全局对象的属性</span>
<span class="nx">setTimeout</span><span class="p">(</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">,</span> <span class="mi">100</span> <span class="p">);</span> <span class="c1">// "oops, global"</span>
</code></pre></div></div>

<p>在我们的函数调用点处产生了 隐式丢失 的情况。如果此处我们使用显式绑定 <code class="highlighter-rouge">call()</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="mi">100</span> <span class="p">);</span> <span class="c1">//throw new TypeError('"callback" argument must be a function');</span>
</code></pre></div></div>

<p>报错的信息是<em>回调参数必须是一个函数</em>。所以我们改成这样就顺利通过了。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">100</span> <span class="p">);</span> <span class="c1">// "oops, global"</span>
</code></pre></div></div>

<h3 id="硬绑定--hard-binding">硬绑定 – Hard Binding</h3>

<p>Hard binding 是 明确绑定 的一个变种。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="nx">obj</span> <span class="p">);</span>
<span class="p">};</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">// 2</span>
<span class="nx">setTimeout</span><span class="p">(</span> <span class="nx">bar</span><span class="p">,</span> <span class="mi">100</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">bar</code> 将 <code class="highlighter-rouge">foo</code> 的 <code class="highlighter-rouge">this</code> 在函数内部强制绑定到 <code class="highlighter-rouge">obj</code>。之后，无论怎样调用函数 <code class="highlighter-rouge">bar()</code>，它总是手动使用 obj 调用 foo。这种绑定态度明确又坚定，所以称之为 hard binding。</p>
</blockquote>

<p>hard binding 的用法一：为所有传入的参数和传出的的返回值创建一个通道</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">something</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">something</span> <span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">something</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span> <span class="nx">obj</span><span class="p">,</span> <span class="kr">arguments</span> <span class="p">);</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span> <span class="c1">// 2 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">b</span> <span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div></div>

<p>hard binding 的用法二：创建一个可复用的帮助函数</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">something</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">something</span> <span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">something</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 简单的 `bind` 帮助函数</span>
<span class="kd">function</span> <span class="nx">bind</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span> <span class="nx">obj</span><span class="p">,</span> <span class="kr">arguments</span> <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">bind</span><span class="p">(</span> <span class="nx">foo</span><span class="p">,</span> <span class="nx">obj</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span> <span class="c1">// 2 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">b</span> <span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div></div>

<p>正因为 harding 是一个如此常用的模式，ES5 将它作为内建工具提供: <code class="highlighter-rouge">Function.prototype.bind</code>。</p>

<p>比如上面的例子。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">something</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">something</span> <span class="p">);</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">something</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span> <span class="nx">obj</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span> <span class="c1">// 2 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">b</span> <span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div></div>

<p>在比如我们 隐式丢失 的那个例子:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">"oops, global"</span><span class="p">;</span> <span class="c1">// `a` 也是一个全局对象的属性</span>
<span class="nx">setTimeout</span><span class="p">(</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">),</span> <span class="mi">100</span> <span class="p">);</span> <span class="c1">// "oops, global"</span>
</code></pre></div></div>

<hr />

<h2 id="new-绑定--new-binding">new 绑定 – new Binding</h2>

<p>这是最后一种 this 绑定规则。在 JavaScript 中，“构造器”仅仅是一个函数，也叫做构造函数。不依附于类，也不初始化一个类，甚至都不是一种特殊的函数种类。本质是一般的函数，只是被使用 <code class="highlighter-rouge">new</code> 来调用时改变了行为。</p>

<p>在函数前面加入 new 调用时，会自动完成下面的事情:</p>

<ul>
  <li>一个全新的对象被构建</li>
  <li>这个新构建的对象会被接入原型链</li>
  <li>新构建的对象被设置为函数调用的 this 绑定</li>
  <li>除非函数返回一个它自己的其他对象，否则这个被 new 调用的函数将自动返回这个新构建的对象</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<hr />

<h2 id="四种规则的顺序">四种规则的顺序</h2>

<ol>
  <li>函数是通过 new 被调用的吗(new 绑定)？如果是，this 就是新构建的对象。
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>函数是通过 call 或 apply 被调用(显式绑定)，甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="nx">obj2</span> <span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>函数是通过上下文对象(也称为拥有者或容器对象)被调用的吗(隐式绑定)？如果是，this 就是那个环境对象
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>否则，使用默认的 this(默认绑定)。如果在 strict mode 下，就是 undefined，否则是 global 对象。
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
</ol>

<hr />

<h2 id="特殊的-this">特殊的 this</h2>

<h3 id="在闭包中使用-this">在闭包中使用 this</h3>

<p>匿名函数的执行环境具有全局性，因此其 this 对象<strong>通常</strong>指向 global 对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="cm">/*
    ... 这些范围内，this 指向 obj
    */</span>
    <span class="kd">function</span> <span class="nx">test</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
        <span class="cm">/*
        ... 这些范围内，this 指向 global
        */</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">test</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span><span class="nx">foo</span>
<span class="p">}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()();</span><span class="c1">//0</span>
</code></pre></div></div>

<p>这种情况其实也是可以使用我们的四个规则来进行判断的，首先看我们的调用点。第一个调用点是 <code class="highlighter-rouge">obj.foo()</code> 这种是满足我们 隐式绑定规则的，this 指向我们的 obj。接着我们的第二个调用点是 <code class="highlighter-rouge">obj.foo()()</code>，这种是非常直白的函数调用，所以退回到 默认绑定，this 指向 global 对象。上面的例子和下面的写法一致，但是表意更清楚。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="cm">/*
    ... 这些范围内，this 指向 obj
    */</span>
    <span class="kd">function</span> <span class="nx">test</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
        <span class="cm">/*
        ... 这些范围内，this 指向 global
        */</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">test</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span><span class="nx">foo</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
<span class="nx">bar</span><span class="p">();</span>
</code></pre></div></div>

<p>我们通常采用<strong>将外部的 this 保存到一个闭包能访问的变量里</strong>来访问该对象。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="cm">/*
    ... 这些范围内，this 指向 obj
    */</span>
    <span class="kd">function</span> <span class="nx">test</span><span class="p">(){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
        <span class="cm">/*
        ... 这些范围内，this 指向 global
        */</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">test</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span><span class="nx">foo</span>
<span class="p">}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()();</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>这似乎是不错的解决方案，但都是为了逃避 this 而非接受它。</p>

<h3 id="iife-中使用-this">IIFE 中使用 this</h3>

<p>通常说，IIFE 中的 this 指向 global 对象。下面是一个非常简单的 IIFE 函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>  <span class="c1">// 2</span>
<span class="p">})();</span>
</code></pre></div></div>

<p>但是，上述的代码和下面的代码没有任何区别:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>  <span class="c1">// 2</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>

<p>很浅显了吧，非常直白的 默认绑定。</p>

<h3 id="传递-null-或-undefined">传递 null 或 undefined</h3>

<p>如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="kc">null</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<h3 id="箭头函数">箭头函数</h3>

<p>ES6 的箭头函数和上述四种规则不同的是，<strong>箭头函数从封闭它的(函数或全局)作用域采用 this 绑定。</strong></p>

<p>最常见的用法是用于回调。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// 这里的 `this` 是词法上从 `foo()` 采用</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
    <span class="p">},</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="nx">obj</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>箭头函数提供除了使用 <code class="highlighter-rouge">bind()</code> 外，另外一种在函数上来确保 this 的方式。但是这种写法和我们上面提到的 <code class="highlighter-rouge">self = this</code> 并无二致。也就是说，上面的代码和下面的代码效果一致:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">},</span><span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="nx">obj</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>没啥区别，对吧。所以，总的来说，都和这四种规则分不开。</p>

<hr />

<h2 id="callapply-和-bind">call、apply 和 bind</h2>

<p><code class="highlighter-rouge">call()</code> 和 <code class="highlighter-rouge">apply()</code> 的区别不再赘述，我们这里想要关注的是 <strong>它们的返回值</strong>。返回值是它们与 <code class="highlighter-rouge">bind()</code> 函数的区别。在 MDN 中，是这样描述的:</p>

<blockquote>
  <p>The result of calling the function with the specified this value and arguments. – MDN</p>
</blockquote>

<p>官方文档的描述在这里: <a href="http://es5.github.io/#x15.3">Function.prototype.apply</a></p>

<blockquote>
  <p>Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value and argList as the list of arguments. – [ES5]</p>
</blockquote>

<p>两者表达一个意思，就是返回 <strong>调用函数的使用特定的 this 和参数所返回的结果</strong>。</p>

<p>举个例子:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//2 'yuer'</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,{</span><span class="na">name</span><span class="p">:</span><span class="s1">'yuer'</span><span class="p">}));</span> <span class="c1">//undefined</span>
</code></pre></div></div>

<p>调用函数 <code class="highlighter-rouge">foo()</code> 没有返回值，所以返回的是 <code class="highlighter-rouge">undefined</code>。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">//2 'yuer'</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">,{</span><span class="na">name</span><span class="p">:</span><span class="s1">'yuer'</span><span class="p">}));</span> <span class="c1">//{ name: 'yuer' }</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">foo()</code> 有返回值，所以返回 <code class="highlighter-rouge">foo()</code> 的返回值。</p>

<p>而，<code class="highlighter-rouge">bind()</code> 函数返回的是一个 <strong>新的函数</strong>。</p>

<blockquote>
  <p>The bind method takes one or more arguments, thisArg and (optionally) arg1, arg2, etc, and returns a new function. – – [ES5]</p>
</blockquote>

<p>也就是说，参数设置 <code class="highlighter-rouge">bind()</code> 和 <code class="highlighter-rouge">call()</code> 是一样的，但是，<code class="highlighter-rouge">bind()</code> 返回一个函数的拷贝。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">,{</span><span class="na">name</span><span class="p">:</span><span class="s1">'yuer'</span><span class="p">}));</span> <span class="c1">//[Function: bound foo]</span>
</code></pre></div></div>

<p>这也就解释了我们上面提到的 <em>call() 和 apply() 无法解决隐式绑定丢失的问题</em>，就是因为要求返回的是一个函数，而 <code class="highlighter-rouge">bind()</code> 正好有这个功能。</p>

<hr />

<h2 id="new-的四个步骤">new 的四个步骤</h2>

<ul>
  <li>一个全新的对象被构建</li>
  <li>这个新构建的对象会被接入原型链</li>
  <li>新构建的对象被设置为函数调用的 this 绑定</li>
  <li>除非函数返回一个它自己的其他对象，否则这个被 new 调用的函数将自动返回这个新构建的对象</li>
</ul>

<p>这四句话看似简单，实则意义深刻。</p>

<p>第一句，new 出来的是一个新对象。第二句，对象被接入原型链？怎么接入，使用 <code class="highlighter-rouge">__prototype__</code>。第三句，将对象作为构造函数调用的 this 绑定。至此，我们来模拟一下:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Fun</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
<span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'yuer'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">objectFac</span><span class="p">(</span><span class="nx">Fun</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
    <span class="nx">Fun</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">per</span> <span class="o">=</span> <span class="nx">objectFac</span><span class="p">(</span><span class="nx">Fun</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">per</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 'yuer'</span>
</code></pre></div></div>

<p>这个看似不错，但是这是一种简单的使用原型来构建对象的一种方法。更一般的，我们是组合使用构造函数模式和原型模式。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Fun</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="nx">Fun</span><span class="p">;</span>
    <span class="nl">getName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这种情况下，我们将 Fun 作为 arguments 的一部分来进行传递。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Fun</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="nx">Fun</span><span class="p">,</span>
    <span class="na">getName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">objectFac</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">Constructor</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kr">arguments</span><span class="p">);</span>  <span class="c1">// arguments 是一个类数组，所以不能直接用数组方法，但是可以借用 Array.prototype 上的方法</span>
    <span class="c1">//var Constructor = Array.prototype.shift.call(arguments);</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
    <span class="nx">Constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span> <span class="c1">// 可以简单地将 arguments 作为参数传递，但是没有办法使用数组方法</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">per</span> <span class="o">=</span> <span class="nx">objectFac</span><span class="p">(</span><span class="nx">Fun</span><span class="p">,</span><span class="s1">'yuer'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">per</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</code></pre></div></div>

<p>上述代码实现了 new 操作符的第一、二和三步。即，创建新的对象、接入原型链、改变 this 的指向。那第四部如何理解呢？我们看一下简化例子:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Fun</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">who</span><span class="p">:</span> <span class="s1">'xiaoke'</span><span class="p">,</span>
        <span class="na">what</span><span class="p">:</span> <span class="s1">'love'</span><span class="p">,</span>
        <span class="na">how</span><span class="p">:</span> <span class="s1">'yuer'</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="nx">Fun</span><span class="p">,</span>
    <span class="na">getName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">per</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Fun</span><span class="p">(</span><span class="s1">'yuer'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">per</span><span class="p">);</span> <span class="c1">// { who: 'xiaoke', what: 'love', how: 'yuer' }</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p>构造函数有返回值，我们只能访问返回内容中的属性。这也就是 new 操作符的第四项内容。然后我们要如何处理 objectFun() 函数呢，也就是说，我们需要判断构造函数是否有返回值，如果有，就返回构造函数的内容。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Fun</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">who</span><span class="p">:</span> <span class="s1">'xiaoke'</span><span class="p">,</span>
        <span class="na">what</span><span class="p">:</span> <span class="s1">'love'</span><span class="p">,</span>
        <span class="na">how</span><span class="p">:</span> <span class="s1">'yuer'</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">Fun</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">constructor</span><span class="p">:</span> <span class="nx">Fun</span><span class="p">,</span>
    <span class="na">getName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
<span class="kd">function</span> <span class="nx">objectFac</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
    <span class="c1">//var Constructor= Array.prototype.shift.call(arguments);</span>
    <span class="kd">var</span> <span class="nx">Constructor</span> <span class="o">=</span> <span class="p">[].</span><span class="nx">shift</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kr">arguments</span><span class="p">);</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">Constructor</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">Constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="kr">arguments</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">ret</span> <span class="o">==</span> <span class="s1">'object'</span> <span class="p">?</span> <span class="nx">ret</span> <span class="p">:</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>

<span class="p">}</span>

<span class="kd">var</span> <span class="nx">per</span> <span class="o">=</span> <span class="nx">objectFac</span><span class="p">(</span><span class="nx">Fun</span><span class="p">,</span><span class="s1">'yuer'</span><span class="p">);</span>
<span class="c1">//var per = new Fun('yuer');</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">per</span><span class="p">);</span>
</code></pre></div></div>

<p>参考</p>

<ul>
  <li>《You Don’t Know JS》</li>
  <li>《JavaScript 高级程序设计》</li>
  <li><a href="https://github.com/jawil/blog/issues/16">不用call和apply方法模拟实现ES5的bind方法</a></li>
  <li><a href="https://github.com/mqyqingfeng/Blog/issues/13">JavaScript深入之new的模拟实现</a></li>
</ul>

            </article>
          <hr>
          <blockquote><p>对于本文内容有问题或建议的小伙伴，欢迎在文章底部留言交流讨论。</p></blockquote>
        </div>
      </div>
      <!--comment-->
      <!--code for 网易云跟帖
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
            <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
            <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
            <script>
            var cloudTieConfig = {
            url: document.location.href, 
            sourceId: "",
            productKey: "b6d55f09637f497389b80bafc11aada1",
            target: "cloud-tie-wrapper"
            };
            var yunManualLoad = true;
            Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
            </script>
          </div>
        </article>
      </div> -->
      <!--Gitment-->
      <div id="container"></div>
      <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
      <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
      <script>
        var gitment = new Gitment({
          id: window.location.pathname, 
          owner: 'liusha529',
          repo: 'liusha529.github.io',
          oauth: {
          client_id: 'b389957bf0758092f3eb',
          client_secret: 'b84e22f17551d822d114d1d1d06244bc8d5fc987',
          },
        })
        gitment.render('container')
      </script>
      
    </div>
  </div>
</div>


    <footer class="footer" role="contentinfo">
	<!--不蒜子pv/uv统计-->
	<div class="post-meta">
            <p>Total <span id="busuanzi_value_site_pv"></span> views，您是本站的第<span id="busuanzi_value_site_uv"></span>个小伙伴，<span id="busuanzi_value_page_pv"></span> Hits</p><br/>
    </div>
	<div class="container">
		<p class="copyright">Copyright © 2017   <a href="https://github.com/maoxiaoke/maoxiaoke.github.io" target="_blank"><code>M/J.</code></a> All rights reserved. </p>
		<p>Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>， Data by <a href="https://tongji.baidu.com/web/23811489/overview/index" target="_blank">Bai Du</a>.</p>
	</div>
	<ul id="gotop"><li><span>TOP</span></li></ul>
</footer>
<script src="http://apps.bdimg.com/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="http://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="/styles/js/function.min.js"></script>
<script src="/styles/js/lessismore.js"></script>
<script src="/styles/js/application.min.js"></script>
  </body>
</html>
